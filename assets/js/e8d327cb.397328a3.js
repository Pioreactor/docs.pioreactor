"use strict";(self.webpackChunkpioreactor=self.webpackChunkpioreactor||[]).push([[8033],{66033:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=i(85893),n=i(11151);const r={title:"Adding a new calibration type",slug:"/adding-calibration-type"},o=void 0,l={id:"Calibrations/Calibrations",title:"Adding a new calibration type",description:"Calibrations went through a major rewrite in the 25.1.x release of Pioreactor. The current design is much more adaptable and simple than the previous design. Let's discuss the key points of the current calibration design:",source:"@site/developer-guide/25-Calibrations/01-Calibrations.md",sourceDirName:"25-Calibrations",slug:"/adding-calibration-type",permalink:"/developer-guide/adding-calibration-type",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Adding a new calibration type",slug:"/adding-calibration-type"},sidebar:"tutorialSidebar",previous:{title:"Adding datasets to the Export Data page",permalink:"/developer-guide/dataset-to-ui"},next:{title:"Local development of Pioreactor",permalink:"/developer-guide/local-development"}},s={},c=[{value:"CLI tools",id:"cli-tools",level:3},{value:"Creating a new device",id:"creating-a-new-device",level:2},{value:"Creating a new calibration type",id:"creating-a-new-calibration-type",level:2},{value:"Creating a new protocol for an existing device",id:"creating-a-new-protocol-for-an-existing-device",level:2},{value:"Adding it to the plugins folder",id:"adding-it-to-the-plugins-folder",level:3},{value:"Tips",id:"tips",level:3}];function d(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Calibrations went through a major rewrite in the 25.1.x release of Pioreactor. The current design is much more adaptable and simple than the previous design. Let's discuss the key points of the current calibration design:"}),"\n",(0,a.jsxs)(t.ol,{start:"0",children:["\n",(0,a.jsxs)(t.li,{children:["A ",(0,a.jsx)(t.em,{children:"calibration"})," relates two variables together. One of the variables is what we can vary (in theory), and the other quantity is the target."]}),"\n",(0,a.jsxs)(t.li,{children:["The calibration relates the two via a ",(0,a.jsx)(t.em,{children:"calibration curve"}),", which is just a mapping between the two variables."]}),"\n",(0,a.jsxs)(t.li,{children:["The Pioreactor has many ",(0,a.jsx)(t.em,{children:"devices"})," that can be calibrated. For example, the OD system, media pump, waste pump, or stirring, can all be improved with a calibration being given. A device can have multiple calibrations, but only one can be ",(0,a.jsx)(t.em,{children:"active"})," at a time. The device looks for the ",(0,a.jsx)(t.em,{children:"active"})," calibration, and uses that in practice."]}),"\n",(0,a.jsxs)(t.li,{children:["A ",(0,a.jsx)(t.em,{children:"protocol"})," can be used to create a calibration for a device. Devices could have multiple protocols that can create calibrations."]}),"\n",(0,a.jsx)(t.li,{children:"A calibration can be given to possible multiple devices. Example: the same calibration can be used for waste and media pumps."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["In practice, calibrations are stored as YAML files on the Pioreactor, in ",(0,a.jsx)(t.code,{children:"~/.pioreactor/storage/calibrations"})," , divided into directories by the associated device. By keeping the calibrations as files (instead of in a database) makes moving, sharing, and editing calibrations really easy."]}),"\n",(0,a.jsx)(t.h3,{id:"cli-tools",children:"CLI tools"}),"\n",(0,a.jsxs)(t.p,{children:["There is a useful CLI available to manage calibrations, too: ",(0,a.jsx)(t.code,{children:"pio calibrations --help"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"creating-a-new-device",children:"Creating a new device"}),"\n",(0,a.jsxs)(t.p,{children:["Create a new device is easy: just add a new folder to ",(0,a.jsx)(t.code,{children:"~/.pioreactor/storage/calibrations"})," with the device name. This device name is used elsewhere, so keep it simple and easy to use."]}),"\n",(0,a.jsxs)(t.p,{children:["For example, let's create a pH device, named ",(0,a.jsx)(t.code,{children:"ph"}),". SSH into your Pioreactor and run"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"mkdir ~/.pioreactor/storage/calibrations/ph\nchown pioreactor:www-data ~/.pioreactor/storage/calibrations/ph\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"chown"})," is required so that the webserver can access that folder to read from it."]}),"\n",(0,a.jsx)(t.h2,{id:"creating-a-new-calibration-type",children:"Creating a new calibration type"}),"\n",(0,a.jsxs)(t.p,{children:["A device can be calibrated by different ",(0,a.jsx)(t.em,{children:"types"})," of calibrations. For example, you many want to relate the volume that pumps move to the duration the pump is ON for, ",(0,a.jsx)(t.em,{children:"or"})," relate the volume to the amount of power applied in 1 second interval. These are different calibration ",(0,a.jsx)(t.em,{children:"types"}),". To create a new calibration type, you need to define its unique schema."]}),"\n",(0,a.jsx)(t.p,{children:"Continuing our pH example, the calibration type for it might look like:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'from pioreactor.structs import CalibrationBase # see this class for the full list of fields\n\nclass PHCalibration(CalibrationBase, kw_only=True, tag="ph"):\n    x: str = "pH"       # required\n    y: str = "Voltage"  # required\n\n    # add some optional metadata fields\n    buffer_solution: t.Literal["4.01", "7.00", "10.01"]\n    electrode_type: str\n\n    # not required, but helpful\n    def voltage_to_ph(self, voltage: float) -> float:\n        return self.predict(voltage)\n\n    def ph_to_voltage(self, ph: float) -> float:\n        return self.ipredict(ph)\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"predict"})," and ",(0,a.jsx)(t.code,{children:"ipredict"})," functions are used to convert between the two variables. The ",(0,a.jsx)(t.code,{children:"i"})," in ",(0,a.jsx)(t.code,{children:"ipredict"}),' stands for "inverse".']}),"\n",(0,a.jsx)(t.h2,{id:"creating-a-new-protocol-for-an-existing-device",children:"Creating a new protocol for an existing device"}),"\n",(0,a.jsxs)(t.p,{children:["Define a ",(0,a.jsx)(t.code,{children:"CalibrationProtocol"})," subclass that will hold metadata for your protocol. It should have a ",(0,a.jsx)(t.code,{children:"run"})," method that returns a calibration (a subclass of ",(0,a.jsx)(t.code,{children:"CalibrationBase"})," - see above)."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'from pioreactor.calibration import CalibrationProtocol\nfrom pioreactor.utils.timing import current_utc_datetime\n\nclass BufferBasedPHProtocol(CalibrationProtocol):\n    target_device = "ph"\n    protocol_name = "buffer_based"\n\n    def run(self, target_device: str) -> PHCalibration:\n        return run_ph_calibration()\n\n\ndef run_ph_calibration() -> PHCalibration:\n    # run the calibration, look at other calibration examples to re use code.\n    ...\n\n    return PHCalibration(\n        calibration_name="ph_calibration",\n        calibrated_on_pioreactor_unit="unit1",\n        created_at=current_utc_datetime(),\n        curve_data_=[2, 3, 5],\n        curve_type="poly",\n        x="Voltage",\n        y="pH",\n        recorded_data={"x": [0.1, 0.2, 0.3], "y": [1.0, 2.0, 3.0]},\n        buffer_solution="10.01",\n        electrode_type="glass"\n    )\n'})}),"\n",(0,a.jsx)(t.h3,{id:"adding-it-to-the-plugins-folder",children:"Adding it to the plugins folder"}),"\n",(0,a.jsxs)(t.p,{children:["You can add your code to the ",(0,a.jsx)(t.code,{children:"~/.pioreactor/plugins"})," folder on the Pioreactor, it will auto-magically populate the CLI\nand UI. To complete our pH example, add the following to a new Python file in the ",(0,a.jsx)(t.code,{children:"~/.pioreactor/plugins"})," folder:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'from pioreactor.calibration import CalibrationProtocol\nfrom pioreactor.structs import CalibrationBase\nfrom pioreactor.utils.timing import current_utc_datetime\n\nclass PHCalibration(CalibrationBase, kw_only=True, tag="ph"):\n    buffer_solution: t.Literal["4.01", "7.00", "10.01"]\n    electrode_type: str\n    x: str = "pH"\n    y: str = "Voltage"\n\n    def voltage_to_ph(self, voltage: float) -> float:\n        return self.predict(voltage)\n\n    def ph_to_voltage(self, ph: float) -> float:\n        return self.ipredict(ph)\n\nclass BufferBasedPHProtocol(CalibrationProtocol):\n    target_device = "ph"\n    protocol_name = "buffer_based"\n\n    def run(self, target_device: str) -> PHCalibration:\n        return run_ph_calibration()\n\n\ndef run_ph_calibration() -> PHCalibration:\n    # run the calibration\n    ...\n\n    return PHCalibration(\n        calibration_name="ph_calibration",\n        calibrated_on_pioreactor_unit="unit1",\n        created_at=current_utc_datetime(),\n        curve_data_=[2, 3, 5],\n        curve_type="poly",\n        x="Voltage",\n        y="pH",\n        recorded_data={"x": [0.1, 0.2, 0.3], "y": [1.0, 2.0, 3.0]},\n        buffer_solution="default",\n        electrode_type="glass"\n    )\n\n'})}),"\n",(0,a.jsx)(t.p,{children:"And run it with:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"pio calibrations run --device ph --protocol-name buffer_based\n"})}),"\n",(0,a.jsx)(t.h3,{id:"tips",children:"Tips"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["use the Python library ",(0,a.jsx)(t.code,{children:"click"})," to create an interactive CLI for your calibration protocol."]}),"\n",(0,a.jsxs)(t.li,{children:["the pair ",(0,a.jsx)(t.code,{children:"(device, calibration_name)"})," must be unique. The final directory structure looks like ",(0,a.jsx)(t.code,{children:"~/.pioreactor/storage/calibrations/<device>/<calibration_name>.yaml"})]}),"\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"x"})," variable should be the independent variable - the variable that can (in theory) be set by you, and the response variable ",(0,a.jsx)(t.code,{children:"y"})," follows. For example, in the default OD calibration, the independent variable is the OD, and the dependent variable is the Pioreactor's sensor's voltage. This is because we can vary the OD as we wish (add more culture...), and the Pioreactor's sensor will detect different values."]}),"\n",(0,a.jsx)(t.li,{children:'Another way to look at this is: "where does error exist"? Typically, there will be error "measurement" variable (voltage for OD calibration, RPM measurement for stirring calibration, etc.)'}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>l,a:()=>o});var a=i(67294);const n={},r=a.createContext(n);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);