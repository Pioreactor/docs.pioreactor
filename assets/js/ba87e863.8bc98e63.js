"use strict";(globalThis.webpackChunkpioreactor=globalThis.webpackChunkpioreactor||[]).push([[8725],{78842(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"Automations/writing-automations-2","title":"Another example writing a new automation","description":"Let\'s design a simple LED automation for Light/Dark cycles. The basic idea is that the LED automation \\"wakes up\\" (specifically: it runs its execute method) every hour, and on specific hours, turns on or turns off the white light LEDs.","source":"@site/developer-guide/04-Automations/03-writing-automations-2.md","sourceDirName":"04-Automations","slug":"/writing-automations-2","permalink":"/developer-guide/writing-automations-2","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Another example writing a new automation","slug":"/writing-automations-2","hide_table_of_contents":true},"sidebar":"tutorialSidebar","previous":{"title":"Writing a new automation","permalink":"/developer-guide/writing-automations-1"},"next":{"title":"Automation events","permalink":"/developer-guide/events"}}');var s=t(74848),o=t(28453);const a={title:"Another example writing a new automation",slug:"/writing-automations-2",hide_table_of_contents:!0},r=void 0,l={},h=[{value:"The Code",id:"the-code",level:3},{value:"Setting up the Pioreactor",id:"setting-up-the-pioreactor",level:3},{value:"Running the automation",id:"running-the-automation",level:3},{value:"Adding the automation to the UI",id:"adding-the-automation-to-the-ui",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:['Let\'s design a simple LED automation for Light/Dark cycles. The basic idea is that the LED automation "wakes up" (specifically: it runs its ',(0,s.jsx)(n.code,{children:"execute"})," method) every hour, and on specific hours, turns on or turns off the white light LEDs."]}),"\n",(0,s.jsx)(n.h3,{id:"the-code",children:"The Code"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Imports at the top of the file!"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# -*- coding: utf-8 -*-\nfrom __future__ import annotations\nfrom pioreactor.automations.led.base import LEDAutomationJobContrib\nfrom pioreactor.whoami import get_unit_name, get_assigned_experiment_name\nfrom pioreactor.automations import events\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["Define a new class as a subclass of ",(0,s.jsx)(n.code,{children:"LEDAutomationJobContrib"}),". We use ",(0,s.jsx)(n.code,{children:"LEDAutomationJobContrib"})," since this is a 3rd party automation. We give the new class a descriptive name. The ",(0,s.jsx)(n.code,{children:"automation_name"})," attribute is necessary - and is often just the camel case version of the class name."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class LightDarkCycle(LEDAutomationJobContrib):\n    automation_name = "light_dark_cycle"\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["Define our ",(0,s.jsx)(n.code,{children:"published_settings"})," for this class. This is a dictionary of ",(0,s.jsx)(n.code,{children:"LightDarkCycle"})," attributes that we can modify/inspect from MQTT (and hence from the UI, or from the leader Pioreactor). Not all attributes need to go in here - only the ones that users may want to modify mid-experiment."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Later in this post, we'll see what each of these attributes does."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'    published_settings = {\n        "duration": {"datatype": "float", "settable": False, "unit": "min"},\n        "light_intensity": {"datatype": "float", "settable": True, "unit": "%"},\n        "light_duration_hours": {"datatype": "float", "settable": True, "unit": "h"},\n        "dark_duration_hours": {"datatype": "float", "settable": True, "unit": "h"},\n    }\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:["Create the ",(0,s.jsx)(n.code,{children:"__init__"}),", with the attributes we'll need."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'    def __init__(self, light_intensity: float, light_duration_hours: int, dark_duration_hours: int, **kwargs):\n        super().__init__(**kwargs)\n        self.hours_online = -1\n        self.light_active = False\n        self.channels = ["B", "C"]\n        self.set_light_intensity(light_intensity)\n        self.light_duration_hours = float(light_duration_hours)\n        self.dark_duration_hours = float(dark_duration_hours)\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hours_online"})," will keep track of how many elapsed hours have gone by."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"light_active"})," keeps track of whether the LEDs are currently on or off"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"channels"})," refers to which LED channels on the Pioreactor HAT we are using."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"light_duration_hours"}),": the number of hours to keep the light on for, typically 16"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dark_duration_hours"}),": the number of hours to keep the light off for, typically 8"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"light_intensity"}),": the level of intensity, as a percent, of the LEDs when turned on."]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsxs)(n.li,{children:["We define the ",(0,s.jsx)(n.code,{children:"execute"})," function, which is what runs every ",(0,s.jsx)(n.code,{children:"duration"})," minutes. In the function, we increment ",(0,s.jsx)(n.code,{children:"hours_online"})," by 1 (since it runs every 60 minutes), and ask a separate function, ",(0,s.jsx)(n.code,{children:"trigger_leds"}),", to handle turning on and off LEDs. The ",(0,s.jsx)(n.code,{children:"execute"})," can return an ",(0,s.jsx)(n.code,{children:"Event"}),", which is useful for logging and testing purposes."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"    def execute(self):\n        self.hours_online += 1\n        event = self.trigger_leds(self.hours_online)\n        return event\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The other class function, ",(0,s.jsx)(n.code,{children:"trigger_leds"}),", role is to:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"determine if we should turn on LEDs, turn off LEDs, or do nothing."}),"\n",(0,s.jsx)(n.li,{children:"If we are changing LEDs status (on to off, or off to on), perform that task."}),"\n",(0,s.jsxs)(n.li,{children:["return an ",(0,s.jsx)(n.code,{children:"Event"}),", with some description of what occurred (even if nothing changed)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["To do 1., we think about the total hours passed ",(0,s.jsx)(n.em,{children:"modulo"})," how long our cycle is. That is, if our cycle lasts 24 hours (which might be the result of choosing 16h light + 8h dark), then the hour 33 is really the same as hour 9, likewise the hour 123 is the same as hour 3: we take the hour modulo the duration."]}),"\n",(0,s.jsxs)(n.p,{children:["We then ask, is this hour in the dark period, or the light period, of the cycle? We also ask if the ",(0,s.jsx)(n.code,{children:"lights_active"})," is on, or off, respectively? If so, we change the status of the LEDs. For example, if we ",(0,s.jsx)(n.em,{children:"should"})," be in the dark period, but our LEDs are on, well, we turn them off, and return a ",(0,s.jsx)(n.code,{children:"ChangeLEDIntensity"})," event. The function ",(0,s.jsx)(n.code,{children:"set_led_intensity"})," is from the parent class, and is a helper function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'    def trigger_leds(self, hours: int) -> events.Event:\n        cycle_duration: int = self.light_duration_hours + self.dark_duration_hours\n\n        if ((hours % cycle_duration) < self.light_duration_hours) and (not self.light_active):\n            self.light_active = True\n            for channel in self.channels:\n                self.set_led_intensity(channel, self.light_intensity)\n            return events.ChangedLedIntensity(f"{hours}h: turned on LEDs")\n        elif ((hours % cycle_duration) >= self.light_duration_hours) and (self.light_active):\n            self.light_active = False\n            for channel in self.channels:\n                self.set_led_intensity(channel, 0)\n            return events.ChangedLedIntensity(f"{hours}h: turned off LEDs")\n        else:\n            return events.NoEvent(f"{hours}h: no change")\n\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We also need to define that ",(0,s.jsx)(n.code,{children:"set_light_intensity"})," function above. This function is automatically called whenever we change ",(0,s.jsx)(n.code,{children:"light_intensity"})," (see note below). We need additional logic to immediately change the ",(0,s.jsx)(n.code,{children:"light_intensity"})," when asked, otherwise, the LEDs wouldn't actually update until the ",(0,s.jsx)(n.em,{children:"next"})," ",(0,s.jsx)(n.code,{children:"execute"})," is called, which could be an hour away."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"    def set_light_intensity(self, intensity) -> None:\n        self.light_intensity = float(intensity)\n        if self.light_active:\n            # update now!\n            for channel in self.channels:\n                self.set_led_intensity(channel, self.light_intensity)\n        else:\n            pass\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Updates over MQTT either update the attribute directly, i.e. :",(0,s.jsx)(n.code,{children:"self.<attr> = new_value"}),", or, if defined, the method ",(0,s.jsx)(n.code,{children:"set_<attr>(new_value)"})," is called instead. This is what is happening with ",(0,s.jsx)(n.code,{children:"set_light_intensity"}),". Using ",(0,s.jsx)(n.code,{children:"set_<attr>"})," methods is useful when you have additional logic that needs to be accomplished when an attribute changes."]})}),"\n",(0,s.jsx)(n.p,{children:"That's the end of the class! In total, our file looks like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# -*- coding: utf-8 -*-\nfrom __future__ import annotations\nfrom pioreactor.automations.led.base import LEDAutomationJobContrib\nfrom pioreactor.automations import events\n\nclass LightDarkCycle(LEDAutomationJobContrib):\n    """\n    Follows as h light / h dark cycle. Starts dark.\n    """\n\n    automation_name = "light_dark_cycle"\n    published_settings = {\n        "duration": {"datatype": "float", "settable": False, "unit": "min"}, # doesn\'t make sense to change duration.\n        "light_intensity": {"datatype": "float", "settable": True, "unit": "%"},\n        "light_duration_hours": {"datatype": "int", "settable": True, "unit": "h"},\n        "dark_duration_hours": {"datatype": "int", "settable": True, "unit": "h"},\n    }\n\n    def __init__(self, light_intensity: float, light_duration_hours: int, dark_duration_hours: int, **kwargs):\n        super().__init__(**kwargs)\n        self.hours_online: int = -1\n        self.light_active: bool = False\n        self.channels = ["B", "C"]\n        self.set_light_intensity(light_intensity)\n        self.light_duration_hours = float(light_duration_hours)\n        self.dark_duration_hours = float(dark_duration_hours)\n\n\n    def trigger_leds(self, hours: int) -> events.Event:\n        cycle_duration: int = self.light_duration_hours + self.dark_duration_hours\n\n        if ((hours % cycle_duration) < self.light_duration_hours) and (not self.light_active):\n            self.light_active = True\n            for channel in self.channels:\n                self.set_led_intensity(channel, self.light_intensity)\n            return events.ChangedLedIntensity(f"{hours}h: turned on LEDs")\n        elif ((hours % cycle_duration) >= self.light_duration_hours) and (self.light_active):\n            self.light_active = False\n            for channel in self.channels:\n                self.set_led_intensity(channel, 0)\n            return events.ChangedLedIntensity(f"{hours}h: turned off LEDs")\n        else:\n            return events.NoEvent(f"{hours}h: no change")\n\n\n    def set_light_intensity(self, intensity) -> None:\n        self.light_intensity = float(intensity)\n        if self.light_active:\n            # update now!\n            for channel in self.channels:\n                self.set_led_intensity(channel, self.light_intensity)\n        else:\n            pass\n\n\n    def execute(self) -> events.Event:\n        self.hours_online += 1\n        event = self.trigger_leds(self.hours_online)\n        return event\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setting-up-the-pioreactor",children:"Setting up the Pioreactor"}),"\n",(0,s.jsxs)(n.p,{children:["Setting up your Pioreactor is easy: attach LEDs to LED channels ",(0,s.jsx)(n.code,{children:"B"})," and ",(0,s.jsx)(n.code,{children:"C"}),", and stick them in pockets ",(0,s.jsx)(n.code,{children:"X2"})," and ",(0,s.jsx)(n.code,{children:"X3"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"running-the-automation",children:"Running the automation"}),"\n",(0,s.jsxs)(n.p,{children:["Let's save this file to our Pioreactor plugin folder, by accessing the Pioreactor's command line, typing ",(0,s.jsx)(n.code,{children:"nano ~/.pioreactor/plugins/light_dark_cycle.py"}),", and pasting in the code above."]}),"\n",(0,s.jsx)(n.p,{children:"You can test the automation from the Pioreactor's command line by executing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"pio run led_automation --automation-name light_dark_cycle --light_intensity 45 --light_duration_hours 16 --dark_duration_hours 8\n"})}),"\n",(0,s.jsx)(n.h3,{id:"adding-the-automation-to-the-ui",children:"Adding the automation to the UI"}),"\n",(0,s.jsxs)(n.p,{children:["To add your automation to the UI so it appears in the automation drop-down, follow the the steps ",(0,s.jsx)(n.a,{href:"/developer-guide/adding-plugins-to-ui#adding-a-custom-automation-to-the-drop-down-of-automations",children:"here"}),"."]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453(e,n,t){t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);