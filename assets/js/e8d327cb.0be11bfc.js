"use strict";(globalThis.webpackChunkpioreactor=globalThis.webpackChunkpioreactor||[]).push([[5413],{21232(e,t,a){a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Calibrations/Calibrations","title":"Adding a new calibration type","description":"Calibrations went through a major rewrite in the 25.1.x release of Pioreactor. The current design is much more adaptable and simple than the previous design. Let\'s discuss the key points of the current calibration design:","source":"@site/developer-guide/25-Calibrations/01-Calibrations.md","sourceDirName":"25-Calibrations","slug":"/adding-calibration-type","permalink":"/developer-guide/adding-calibration-type","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Adding a new calibration type","slug":"/adding-calibration-type","hide_table_of_contents":true},"sidebar":"tutorialSidebar","previous":{"title":"Adding datasets to the Export Data page","permalink":"/developer-guide/dataset-to-ui"},"next":{"title":"Local development of Pioreactor","permalink":"/developer-guide/local-development"}}');var n=a(74848),r=a(28453);const o={title:"Adding a new calibration type",slug:"/adding-calibration-type",hide_table_of_contents:!0},l=void 0,s={},c=[{value:"CLI tools",id:"cli-tools",level:3},{value:"Creating a new device",id:"creating-a-new-device",level:2},{value:"Creating a new calibration type",id:"creating-a-new-calibration-type",level:2},{value:"(Optional) Creating a new protocol for an existing device",id:"optional-creating-a-new-protocol-for-an-existing-device",level:2},{value:"Adding it to the plugins folder",id:"adding-it-to-the-plugins-folder",level:2},{value:"Tips",id:"tips",level:2}];function d(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Calibrations went through a major rewrite in the 25.1.x release of Pioreactor. The current design is much more adaptable and simple than the previous design. Let's discuss the key points of the current calibration design:"}),"\n",(0,n.jsxs)(t.ol,{start:"0",children:["\n",(0,n.jsxs)(t.li,{children:["A ",(0,n.jsx)(t.em,{children:"calibration"})," relates two variables together. One of the variables is what we can vary (in theory), and the other quantity is the target."]}),"\n",(0,n.jsxs)(t.li,{children:["The calibration relates the two via a ",(0,n.jsx)(t.em,{children:"calibration curve"}),", which is just a mapping between the two variables."]}),"\n",(0,n.jsxs)(t.li,{children:["The Pioreactor has many ",(0,n.jsx)(t.em,{children:"devices"})," that can be calibrated. For example, the OD system, media pump, waste pump, or stirring, can all be improved with a calibration being given. A device can have multiple calibrations, but only one can be ",(0,n.jsx)(t.em,{children:"active"})," at a time. The device looks for the ",(0,n.jsx)(t.em,{children:"active"})," calibration, and uses that in practice."]}),"\n",(0,n.jsxs)(t.li,{children:["A ",(0,n.jsx)(t.em,{children:"protocol"})," can be used to create a calibration for a device. Devices could have multiple protocols that can create calibrations."]}),"\n",(0,n.jsx)(t.li,{children:"A calibration can be given to possible multiple devices. Example: the same calibration can be used for waste and media pumps."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["In practice, calibrations are stored as YAML files on the Pioreactor, in ",(0,n.jsx)(t.code,{children:"~/.pioreactor/storage/calibrations"})," , divided into directories by the associated device. By keeping the calibrations as files (instead of in a database) makes moving, sharing, and editing calibrations really easy."]}),"\n",(0,n.jsx)(t.mermaid,{value:'flowchart TD\n    Protocol["<b>Calibration protocol</b><br/>(script or workflow)"] --\x3e|targets| Device["<b>Device</b><br/>(od, pump, stirring, ph, ...)"]\n    Protocol --\x3e|creates| Calibration["<b>Calibration record</b><br/>(data + metadata)"]\n    Device --\x3e|has many| Calibration\n    Device --\x3e|uses| Active["<b>Active calibration</b><br/>(up to one per device)"]\n    Active --\x3e Calibration\n    Calibration --\x3e|is a| CalType["<b>Calibration type</b><br/>(schema)"]\n    Calibration --\x3e|contains| Curve["<b>Calibration curve</b><br/>(model + parameters)"]\n    Curve --\x3e Variables["Maps variables<br/><b>x</b> (independent) <-> <b>y</b> (dependent)"]\n    Calibration --\x3e|stored as files under| Storage["<b>Storage</b><br/>~/.pioreactor/storage/calibrations/<device>/"]'}),"\n",(0,n.jsx)(t.h3,{id:"cli-tools",children:"CLI tools"}),"\n",(0,n.jsxs)(t.p,{children:["There is a useful CLI available to manage calibrations, too: ",(0,n.jsx)(t.code,{children:"pio calibrations --help"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"creating-a-new-device",children:"Creating a new device"}),"\n",(0,n.jsxs)(t.p,{children:["Create a new device is easy: just add a new folder to ",(0,n.jsx)(t.code,{children:"~/.pioreactor/storage/calibrations"})," with the device name. This device name is used elsewhere, so keep it simple and easy to use."]}),"\n",(0,n.jsxs)(t.p,{children:["For example, let's create a pH device, named ",(0,n.jsx)(t.code,{children:"ph"}),". SSH into your Pioreactor and run"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"mkdir ~/.pioreactor/storage/calibrations/ph\nchown pioreactor:www-data ~/.pioreactor/storage/calibrations/ph\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"chown"})," is required so that the webserver can access that folder to read from it."]}),"\n",(0,n.jsx)(t.h2,{id:"creating-a-new-calibration-type",children:"Creating a new calibration type"}),"\n",(0,n.jsxs)(t.p,{children:["A device can be calibrated by different ",(0,n.jsx)(t.em,{children:"types"})," of calibrations. For example, you many want to relate the volume that pumps move to the duration the pump is ON for, ",(0,n.jsx)(t.em,{children:"or"})," relate the volume to the amount of power applied in 1 second interval. These are different calibration ",(0,n.jsx)(t.em,{children:"types"}),". To create a new calibration type, you need to define its unique schema."]}),"\n",(0,n.jsx)(t.p,{children:"Continuing our pH example, the calibration type for it might look like:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from pioreactor.structs import CalibrationBase # see this class for the full list of fields\n\nclass PHBufferCalibration(CalibrationBase, kw_only=True, tag="ph_buffer"):\n    x: str = "pH"       # required\n    y: str = "Voltage"  # required\n\n    # add some optional metadata fields\n    buffer_solution: t.Literal["4.01", "7.00", "10.01"]\n    electrode_type: str\n\n    # not required, but helpful\n    def voltage_to_ph(self, voltage: float) -> float:\n        return self.y_to_x(voltage)\n\n    def ph_to_voltage(self, ph: float) -> float:\n        return self.x_to_y(ph)\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"tag"})," should be unique for this calibration type. For example, if we instead had another pH calibration type that used optics instead of buggers, we could define another pH calibration type as follows:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'class PHOpticsCalibration(CalibrationBase, kw_only=True, tag="optical_ph"):\n    x: str = "pH"\n    y: str = "Lumens"\n'})}),"\n",(0,n.jsxs)(t.p,{children:["It's optional, but we also defined some helper functions ",(0,n.jsx)(t.code,{children:"voltage_to_ph"})," and ",(0,n.jsx)(t.code,{children:"ph_to_voltage"})," to easily map between the variables. Internally, They call ",(0,n.jsx)(t.code,{children:"x_to_y"})," and ",(0,n.jsx)(t.code,{children:"y_to_x"})," functions which are always available on a calibration object. They do the hard math behind mapping variables to each other."]}),"\n",(0,n.jsx)(t.h2,{id:"optional-creating-a-new-protocol-for-an-existing-device",children:"(Optional) Creating a new protocol for an existing device"}),"\n",(0,n.jsx)(t.p,{children:"If you want to add a custom script to create a calibration on the Pioreactor, you can do that by creating a new protocol."}),"\n",(0,n.jsxs)(t.p,{children:["Define a ",(0,n.jsx)(t.code,{children:"CalibrationProtocol"})," subclass that will hold metadata for your protocol. It should have a ",(0,n.jsx)(t.code,{children:"run"})," method that returns a calibration (a subclass of ",(0,n.jsx)(t.code,{children:"CalibrationBase"})," - see above)."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from pioreactor.calibrations import CalibrationProtocol\nfrom pioreactor.utils.timing import current_utc_datetime\nfrom pioreactor import whoami\n\n\nclass BufferBasedPHProtocol(CalibrationProtocol):\n    target_device = "ph"\n    protocol_name = "buffer_based"\n    description = "Calibrate the pH sensor using buffer solutions"\n\n    def run(self, target_device: str):\n        return run_ph_buffer_calibration()\n\n\ndef run_ph_buffer_calibration():\n    # run the calibration, look at other calibration examples to re use code.\n    ...\n\n    return PHBufferCalibration(\n        calibration_name="ph_calibration",\n        calibrated_on_pioreactor_unit=whoami.get_unit_name(),\n        created_at=current_utc_datetime(),\n        curve_data_=[2, 3, 5],\n        curve_type="poly",\n        x="Voltage",\n        y="pH",\n        recorded_data={"x": [0.1, 0.2, 0.3], "y": [1.0, 2.0, 3.0]},\n        buffer_solution="10.01",\n        electrode_type="glass"\n    )\n'})}),"\n",(0,n.jsx)(t.h2,{id:"adding-it-to-the-plugins-folder",children:"Adding it to the plugins folder"}),"\n",(0,n.jsxs)(t.p,{children:["You can add your code to the ",(0,n.jsx)(t.code,{children:"~/.pioreactor/plugins"})," folder on the Pioreactor, it will auto-magically populate the CLI\nand UI. To complete our pH example, add the following to a new Python file in the ",(0,n.jsx)(t.code,{children:"~/.pioreactor/plugins"})," folder:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from __future__ import annotations\nfrom pioreactor.calibrations import CalibrationProtocol\nfrom pioreactor.structs import CalibrationBase\nfrom pioreactor.utils.timing import current_utc_datetime\nfrom pioreactor import whoami\nimport typing as t\n\nclass PHBufferCalibration(CalibrationBase, kw_only=True, tag="ph_buffer"):\n    x: str = "pH"       # required\n    y: str = "Voltage"  # required\n\n    buffer_solution: t.Literal["4.01", "7.00", "10.01"]\n    electrode_type: str\n\n    def voltage_to_ph(self, voltage: float):\n        return self.y_to_x(voltage)\n\n    def ph_to_voltage(self, ph: float):\n        return self.x_to_y(ph)\n\nclass BufferBasedPHProtocol(CalibrationProtocol):\n    target_device = "ph"\n    protocol_name = "buffer_based"\n    description = "Calibrate the pH sensor using buffer solutions"\n\n    def run(self, target_device: str):\n        return run_ph_buffer_calibration()\n\ndef run_ph_buffer_calibration():\n    # run the calibration to get data\n    ...\n\n    return PHBufferCalibration(\n        calibration_name="ph_calibration",\n        calibrated_on_pioreactor_unit=whoami.get_unit_name(),\n        created_at=current_utc_datetime(),\n        curve_data_=[2, 3, 5],\n        curve_type="poly",\n        x="Voltage",\n        y="pH",\n        recorded_data={"x": [0.1, 0.2, 0.3], "y": [1.0, 2.0, 3.0]},\n        buffer_solution="default",\n        electrode_type="glass"\n    )\n\n'})}),"\n",(0,n.jsx)(t.p,{children:"And run it with:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"pio calibrations run --device ph\n"})}),"\n",(0,n.jsx)(t.h2,{id:"tips",children:"Tips"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["use the Python library ",(0,n.jsx)(t.code,{children:"click"})," to create an interactive CLI for your calibration protocol."]}),"\n",(0,n.jsxs)(t.li,{children:["the pair ",(0,n.jsx)(t.code,{children:"(device, calibration_name)"})," must be unique. The final directory structure looks like ",(0,n.jsx)(t.code,{children:"~/.pioreactor/storage/calibrations/<device>/<calibration_name>.yaml"})]}),"\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.code,{children:"x"})," variable should be the independent variable - the variable that can (in theory) be set by you, and the measurement variable ",(0,n.jsx)(t.code,{children:"y"})," follows. For example, in the default OD calibration, the independent variable is the OD, and the dependent variable is the Pioreactor's sensor's voltage. This is because we can vary the OD as we wish (add more culture...), and the Pioreactor's sensor will detect different values."]}),"\n",(0,n.jsx)(t.li,{children:'Another way to look at this is: "where does error exist"? Typically, there will be error in the "measurement" variable (voltage for OD calibration, RPM measurement for stirring calibration, etc.). In practice, we only have the measurement variable, and wish to go "back" to the original variable.'}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453(e,t,a){a.d(t,{R:()=>o,x:()=>l});var i=a(96540);const n={},r=i.createContext(n);function o(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);