"use strict";(self.webpackChunkpioreactor=self.webpackChunkpioreactor||[]).push([[4350],{12154:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>t,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var n=i(85893),s=i(11151);const o={title:"Customize the hardware interface",slug:"/custom-hardware",description:"Extend or override Pioreactor hardware definitions by layering YAML files that hardware.py reads.",hide_table_of_contents:!0},d=void 0,a={id:"Hardware/custom-hardware",title:"Customize the hardware interface",description:"Extend or override Pioreactor hardware definitions by layering YAML files that hardware.py reads.",source:"@site/developer-guide/10-Hardware/10-custom-hardware.md",sourceDirName:"10-Hardware",slug:"/custom-hardware",permalink:"/developer-guide/custom-hardware",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Customize the hardware interface",slug:"/custom-hardware",description:"Extend or override Pioreactor hardware definitions by layering YAML files that hardware.py reads.",hide_table_of_contents:!0},sidebar:"tutorialSidebar",previous:{title:"Adding behaviour to the HAT's button",permalink:"/developer-guide/hat-button"},next:{title:"Custom bioreactor models",permalink:"/developer-guide/custom-bioreactor-models"}},t={},c=[{value:"How the loader works",id:"how-the-loader-works",level:2},{value:"Step-by-step: add a custom hardware profile",id:"step-by-step-add-a-custom-hardware-profile",level:2},{value:"Tips for customization",id:"tips-for-customization",level:2}];function l(e){const r={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["Pioreactor's hardware layer is intentionally data-driven. Everything in ",(0,n.jsx)(r.a,{href:"https://github.com/pioreactor/pioreactor/blob/main/core/pioreactor/hardware.py",children:(0,n.jsx)(r.code,{children:"core/pioreactor/hardware.py"})})," loads user-editable YAML files from ",(0,n.jsx)(r.code,{children:"~/.pioreactor/hardware/"})," (or the folder pointed to by the ",(0,n.jsx)(r.code,{children:"DOT_PIOREACTOR"})," env var). By editing these files you can rewire pins, add new peripherals, or describe an entirely new bioreactor model without touching the Python code. Pair these configs with ",(0,n.jsx)(r.a,{href:"/developer-guide/custom-bioreactor-models",children:"custom bioreactor model definitions"})," so the UI, safety limits, and wiring stay in sync."]}),"\n",(0,n.jsx)(r.h2,{id:"how-the-loader-works",children:"How the loader works"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"hardware.py"})," deep-merges two directories for each ",(0,n.jsx)(r.strong,{children:"mod"})," (subsystem):"]}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"~/.pioreactor/hardware/hats/<hat_version>/<mod>.yaml"})," \u2013 physical wiring that ships with a specific HAT revision (",(0,n.jsx)(r.code,{children:"hardware_version_info"}),")."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"~/.pioreactor/hardware/models/<model>/<version>/<mod>.yaml"})," \u2013 intent for a particular bioreactor model returned by ",(0,n.jsx)(r.code,{children:"get_pioreactor_model()"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["Later layers override earlier ones. Missing files are allowed; missing keys throw ",(0,n.jsx)(r.code,{children:"HardwareError"}),"s when helpers such as ",(0,n.jsx)(r.code,{children:"get_pwm_to_pin_map()"})," run."]}),"\n",(0,n.jsxs)(r.p,{children:["Common mods defined inside ",(0,n.jsx)(r.code,{children:"hardware.py"})," are:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"pwm.yaml"})," (",(0,n.jsx)(r.code,{children:"get_pwm_controller"}),", ",(0,n.jsx)(r.code,{children:"get_heater_pwm_channel"}),", ",(0,n.jsx)(r.code,{children:"get_pwm_to_pin_map"}),")"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"gpio.yaml"})," (",(0,n.jsx)(r.code,{children:"get_pcb_led_pin"}),", ",(0,n.jsx)(r.code,{children:"get_hall_sensor_pin"}),", ",(0,n.jsx)(r.code,{children:"get_sda_pin"}),", ",(0,n.jsx)(r.code,{children:"get_scl_pin"}),")"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"temp.yaml"})," (",(0,n.jsx)(r.code,{children:"get_temp_address"}),", used by ",(0,n.jsx)(r.code,{children:"is_heating_pcb_present"}),")"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"adc.yaml"})," (",(0,n.jsx)(r.code,{children:"get_adc_curriers"}),", which subsequently powers PD channel helpers)"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"dac.yaml"})," (",(0,n.jsx)(r.code,{children:"get_dac_address"}),")"]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["You can add additional mods with any key/value structure\u2014",(0,n.jsx)(r.code,{children:'get_layered_mod_config("my_mod")'})," will still combine the YAML files."]}),"\n",(0,n.jsx)(r.h2,{id:"step-by-step-add-a-custom-hardware-profile",children:"Step-by-step: add a custom hardware profile"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Create directories"})," for your HAT and model version."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"mkdir -p ~/.pioreactor/hardware/hats/<hat_version>\nmkdir -p ~/.pioreactor/hardware/models/<model_name>/<model_version>\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Use ",(0,n.jsx)(r.code,{children:"pioreactor.version.hardware_version_info"})," (for hats) and your ",(0,n.jsx)(r.code,{children:"pioreactor.models"})," entry for models."]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Describe the wiring"})," (hat layer). Example ",(0,n.jsx)(r.code,{children:"~/.pioreactor/hardware/hats/0.2/pwm.yaml"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-yaml",children:'controller: hat_mcu\nheater_pwm_channel: "5"\npwm_to_pin:\n  "1": 17\n  "2": 13\n  "5": 18\n'})}),"\n",(0,n.jsxs)(r.p,{children:["These keys map directly to ",(0,n.jsx)(r.code,{children:"_load_pwm_cfg()"})," in ",(0,n.jsx)(r.code,{children:"hardware.py"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Describe the capabilities"})," (model layer). Suppose you added a new auxiliary photodiode ADC:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-yaml",metastring:'title="~/.pioreactor/hardware/models/my_model/v1.0/adc.yaml"',children:"pd1:\n  driver: ADS1115\n  address: 0x48\n  channel: 0\naux:\n  driver: pico\n  address: 0x40\n  channel: 0\nsalty:\n  driver: ADS1115\n  address: 0x49\n  channel: 2\n"})}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"get_adc_curriers()"})," will automatically expose ",(0,n.jsx)(r.code,{children:".keys()"})," for every entry (",(0,n.jsx)(r.code,{children:"pd1"}),", ",(0,n.jsx)(r.code,{children:"aux"}),", ",(0,n.jsx)(r.code,{children:"salty"}),"). Downstream helpers, like ",(0,n.jsx)(r.code,{children:"get_available_pd_channels()"}),", treat ",(0,n.jsx)(r.code,{children:"pd*"})," names as photodiode channels."]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Reference new mods in code"}),". Anywhere in your plugin/automation you can import:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-python",children:'from pioreactor.hardware import get_layered_mod_config\n\nstir_cfg = get_layered_mod_config("stirrer")  # merges hats/<hat>/stirrer.yaml and models/<model>/stirrer.yaml\nif stir_cfg.get("controller") == "pico":\n    ...\n'})}),"\n",(0,n.jsx)(r.p,{children:"This keeps custom hardware logic outside Pioreactor core."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"tips-for-customization",children:"Tips for customization"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["Use integers for all addresses and pins; ",(0,n.jsx)(r.code,{children:"hardware.py"})," casts everything via ",(0,n.jsx)(r.code,{children:"int()"})," and will raise if parsing fails."]}),"\n",(0,n.jsx)(r.li,{children:"Keep YAML minimal\u2014only override keys that differ from the hat defaults to take advantage of deep-merge layering."}),"\n",(0,n.jsxs)(r.li,{children:["The helper predicates (",(0,n.jsx)(r.code,{children:"is_ADC_present"}),", ",(0,n.jsx)(r.code,{children:"is_heating_pcb_present"}),", etc.) are safe ways to gate optional hardware in your jobs."]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["Once you describe the hardware this way, the rest of the stack\u2014jobs, automations, plugins\u2014just asks ",(0,n.jsx)(r.code,{children:"hardware.py"})," for the capabilities it needs, so new hardware becomes a configuration exercise instead of a fork of the core codebase."]})]})}function h(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},11151:(e,r,i)=>{i.d(r,{Z:()=>a,a:()=>d});var n=i(67294);const s={},o=n.createContext(s);function d(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);