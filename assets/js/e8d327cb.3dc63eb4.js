"use strict";(globalThis.webpackChunkpioreactor=globalThis.webpackChunkpioreactor||[]).push([[5413],{21232(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Calibrations/Calibrations","title":"Adding a new calibration type","description":"Calibrations went through a major rewrite in the 25.1.x release of Pioreactor. The current design is much more adaptable and simple than the previous design. Let\'s discuss the key points of the current calibration design:","source":"@site/developer-guide/25-Calibrations/01-Calibrations.md","sourceDirName":"25-Calibrations","slug":"/adding-calibration-type","permalink":"/developer-guide/adding-calibration-type","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Adding a new calibration type","slug":"/adding-calibration-type","hide_table_of_contents":true,"sidebar_class_name":"sidebar-item--updated"},"sidebar":"tutorialSidebar","previous":{"title":"Adding datasets to the Export Data page","permalink":"/developer-guide/dataset-to-ui"},"next":{"title":"Local development of Pioreactor","permalink":"/developer-guide/local-development"}}');var a=t(74848),r=t(28453);const o={title:"Adding a new calibration type",slug:"/adding-calibration-type",hide_table_of_contents:!0,sidebar_class_name:"sidebar-item--updated"},s=void 0,l={},c=[{value:"CLI tools",id:"cli-tools",level:3},{value:"Creating a new device",id:"creating-a-new-device",level:2},{value:"Creating a new calibration type",id:"creating-a-new-calibration-type",level:2},{value:"(Optional) Creating a new protocol for an existing device",id:"optional-creating-a-new-protocol-for-an-existing-device",level:2},{value:"Session-based flows (UI + CLI)",id:"session-based-flows-ui--cli",level:2},{value:"Adding it to the plugins folder",id:"adding-it-to-the-plugins-folder",level:2},{value:"Tips",id:"tips",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Calibrations went through a major rewrite in the 25.1.x release of Pioreactor. The current design is much more adaptable and simple than the previous design. Let's discuss the key points of the current calibration design:"}),"\n",(0,a.jsxs)(n.ol,{start:"0",children:["\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.em,{children:"calibration"})," relates two variables together. One of the variables is what we can vary (in theory), and the other quantity is the target."]}),"\n",(0,a.jsxs)(n.li,{children:["The calibration relates the two via a ",(0,a.jsx)(n.em,{children:"calibration curve"}),", which is just a mapping between the two variables."]}),"\n",(0,a.jsxs)(n.li,{children:["The Pioreactor has many ",(0,a.jsx)(n.em,{children:"devices"})," that can be calibrated. For example, the OD system, media pump, waste pump, or stirring, can all be improved with a calibration being given. A device can have multiple calibrations, but only one can be ",(0,a.jsx)(n.em,{children:"active"})," at a time. The device looks for the ",(0,a.jsx)(n.em,{children:"active"})," calibration, and uses that in practice."]}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.em,{children:"protocol"})," can be used to create a calibration for a device. Devices could have multiple protocols that can create calibrations."]}),"\n",(0,a.jsx)(n.li,{children:"A calibration can be given to possible multiple devices. Example: the same calibration can be used for waste and media pumps."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In practice, calibrations are stored as YAML files on the Pioreactor, in ",(0,a.jsx)(n.code,{children:"~/.pioreactor/storage/calibrations"})," , divided into directories by the associated device. By keeping the calibrations as files (instead of in a database) makes moving, sharing, and editing calibrations really easy."]}),"\n",(0,a.jsx)(n.mermaid,{value:'flowchart TD\n    Protocol["<b>Calibration protocol</b><br/>(script or workflow)"] --\x3e|targets| Device["<b>Device</b><br/>(od, pump, stirring, ph, ...)"]\n    Protocol --\x3e|creates| Calibration["<b>Calibration record</b><br/>(data + metadata)"]\n    Device --\x3e|has many| Calibration\n    Device --\x3e|uses| Active["<b>Active calibration</b><br/>(up to one per device)"]\n    Active --\x3e Calibration\n    Calibration --\x3e|is a| CalType["<b>Calibration type</b><br/>(schema)"]\n    Calibration --\x3e|contains| Curve["<b>Calibration curve</b><br/>(model + parameters)"]\n    Curve --\x3e Variables["Maps variables<br/><b>x</b> (independent) <-> <b>y</b> (dependent)"]\n    Calibration --\x3e|stored as files under| Storage["<b>Storage</b><br/>~/.pioreactor/storage/calibrations/<device>/"]'}),"\n",(0,a.jsx)(n.h3,{id:"cli-tools",children:"CLI tools"}),"\n",(0,a.jsxs)(n.p,{children:["There is a useful CLI available to manage calibrations, too: ",(0,a.jsx)(n.code,{children:"pio calibrations --help"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"creating-a-new-device",children:"Creating a new device"}),"\n",(0,a.jsxs)(n.p,{children:["Create a new device is easy: just add a new folder to ",(0,a.jsx)(n.code,{children:"~/.pioreactor/storage/calibrations"})," with the device name. This device name is used elsewhere, so keep it simple and easy to use."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, let's create a pH device, named ",(0,a.jsx)(n.code,{children:"ph"}),". SSH into your Pioreactor and run"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"mkdir ~/.pioreactor/storage/calibrations/ph\nchown pioreactor:www-data ~/.pioreactor/storage/calibrations/ph\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"chown"})," is required so that the webserver can access that folder to read from it."]}),"\n",(0,a.jsx)(n.h2,{id:"creating-a-new-calibration-type",children:"Creating a new calibration type"}),"\n",(0,a.jsxs)(n.p,{children:["A device can be calibrated by different ",(0,a.jsx)(n.em,{children:"types"})," of calibrations. For example, you many want to relate the volume that pumps move to the duration the pump is ON for, ",(0,a.jsx)(n.em,{children:"or"})," relate the volume to the amount of power applied in 1 second interval. These are different calibration ",(0,a.jsx)(n.em,{children:"types"}),". To create a new calibration type, you need to define its unique schema."]}),"\n",(0,a.jsx)(n.p,{children:"Continuing our pH example, the calibration type for it might look like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from pioreactor.structs import CalibrationBase # see this class for the full list of fields\n\nclass PHBufferCalibration(CalibrationBase, kw_only=True, tag="ph_buffer"):\n    x: str = "pH"       # required\n    y: str = "Voltage"  # required\n\n    # add some optional metadata fields\n    buffer_solution: t.Literal["4.01", "7.00", "10.01"]\n    electrode_type: str\n\n    # not required, but helpful\n    def voltage_to_ph(self, voltage: float) -> float:\n        return self.y_to_x(voltage)\n\n    def ph_to_voltage(self, ph: float) -> float:\n        return self.x_to_y(ph)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"tag"})," should be unique for this calibration type. For example, if we instead had another pH calibration type that used optics instead of buggers, we could define another pH calibration type as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class PHOpticsCalibration(CalibrationBase, kw_only=True, tag="optical_ph"):\n    x: str = "pH"\n    y: str = "Lumens"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["It's optional, but we also defined some helper functions ",(0,a.jsx)(n.code,{children:"voltage_to_ph"})," and ",(0,a.jsx)(n.code,{children:"ph_to_voltage"})," to easily map between the variables. Internally, They call ",(0,a.jsx)(n.code,{children:"x_to_y"})," and ",(0,a.jsx)(n.code,{children:"y_to_x"})," functions which are always available on a calibration object. They do the hard math behind mapping variables to each other."]}),"\n",(0,a.jsx)(n.h2,{id:"optional-creating-a-new-protocol-for-an-existing-device",children:"(Optional) Creating a new protocol for an existing device"}),"\n",(0,a.jsx)(n.p,{children:"If you want to add a custom script to create a calibration on the Pioreactor, you can do that by creating a new protocol."}),"\n",(0,a.jsxs)(n.p,{children:["Define a ",(0,a.jsx)(n.code,{children:"CalibrationProtocol"})," subclass that will hold metadata for your protocol. It should have a ",(0,a.jsx)(n.code,{children:"run"})," method that returns a calibration (a subclass of ",(0,a.jsx)(n.code,{children:"CalibrationBase"})," - see above). If your protocol supports session-based UI/CLI flows, also define a step registry and a ",(0,a.jsx)(n.code,{children:"start_session"})," classmethod."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from pioreactor.calibrations import CalibrationProtocol\nfrom pioreactor.utils.timing import current_utc_datetime\nfrom pioreactor import whoami\n\n\nclass BufferBasedPHProtocol(CalibrationProtocol):\n    target_device = "ph"\n    protocol_name = "buffer_based"\n    description = "Calibrate the pH sensor using buffer solutions"\n    step_registry = PH_STEPS\n\n    @classmethod\n    def start_session(cls, target_device: str) -> CalibrationSession:\n        return start_ph_buffer_session(target_device)\n\n    def run(self, target_device: str):\n        return run_ph_buffer_calibration()\n\n\ndef run_ph_buffer_calibration():\n    # run the calibration, look at other calibration examples to re use code.\n    ...\n\n    return PHBufferCalibration(\n        calibration_name="ph_calibration",\n        calibrated_on_pioreactor_unit=whoami.get_unit_name(),\n        created_at=current_utc_datetime(),\n        curve_data_=[2, 3, 5],\n        curve_type="poly",\n        x="Voltage",\n        y="pH",\n        recorded_data={"x": [0.1, 0.2, 0.3], "y": [1.0, 2.0, 3.0]},\n        buffer_solution="10.01",\n        electrode_type="glass"\n    )\n'})}),"\n",(0,a.jsx)(n.h2,{id:"session-based-flows-ui--cli",children:"Session-based flows (UI + CLI)"}),"\n",(0,a.jsxs)(n.p,{children:["Session-based calibrations use ",(0,a.jsx)(n.code,{children:"SessionStep"})," classes to define the flow once and render it in both the UI and CLI. A typical pattern is:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Define ",(0,a.jsx)(n.code,{children:"SessionStep"})," subclasses with ",(0,a.jsx)(n.code,{children:"step_id"}),", ",(0,a.jsx)(n.code,{children:"render(ctx)"}),", and ",(0,a.jsx)(n.code,{children:"advance(ctx)"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Create a ",(0,a.jsx)(n.code,{children:"StepRegistry"})," mapping ",(0,a.jsx)(n.code,{children:"{step_id: StepClass}"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Expose ",(0,a.jsx)(n.code,{children:"start_<protocol>_session"}),", ",(0,a.jsx)(n.code,{children:"get_<protocol>_step"})," (uses ",(0,a.jsx)(n.code,{children:"get_session_step"}),"), and ",(0,a.jsx)(n.code,{children:"advance_<protocol>_session"})," (uses ",(0,a.jsx)(n.code,{children:"advance_session"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:["In ",(0,a.jsx)(n.code,{children:"run(...)"}),", call ",(0,a.jsx)(n.code,{children:"run_session_in_cli(step_registry, session)"})," to reuse the same flow in CLI."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Key details:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Step classes should keep ",(0,a.jsx)(n.code,{children:"render"})," (display) and ",(0,a.jsx)(n.code,{children:"advance"})," (state changes) single-purpose and explicit."]}),"\n",(0,a.jsxs)(n.li,{children:["Terminal steps are auto-included by ",(0,a.jsx)(n.code,{children:"get_session_step"}),", ",(0,a.jsx)(n.code,{children:"advance_session"}),", and ",(0,a.jsx)(n.code,{children:"run_session_in_cli"}),". Use ",(0,a.jsx)(n.code,{children:"ctx.complete(...)"})," to finish (renders ",(0,a.jsx)(n.code,{children:"CalibrationComplete"}),") and ",(0,a.jsx)(n.code,{children:"ctx.abort(...)"})," / ",(0,a.jsx)(n.code,{children:"ctx.fail(...)"})," to end early (renders ",(0,a.jsx)(n.code,{children:"CalibrationEnded"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:["UI sessions must perform hardware access through the Huey executor (",(0,a.jsx)(n.code,{children:"SessionContext.executor"}),"). Define executor actions in ",(0,a.jsx)(n.code,{children:"core/pioreactor/web/tasks.py"})," and dispatch them from ",(0,a.jsx)(n.code,{children:"core/pioreactor/web/unit_calibration_sessions_api.py"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Chart snapshots: populate ",(0,a.jsx)(n.code,{children:"step.metadata.chart"})," with ",(0,a.jsx)(n.code,{children:"title"}),", ",(0,a.jsx)(n.code,{children:"x_label"}),", ",(0,a.jsx)(n.code,{children:"y_label"}),", and ",(0,a.jsx)(n.code,{children:"series"})," (points + optional curve). The UI renders them and the CLI uses plotext via ",(0,a.jsx)(n.code,{children:"plot_data"})," in ",(0,a.jsx)(n.code,{children:"core/pioreactor/calibrations/utils.py"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This keeps CLI and UI behavior consistent and avoids bespoke click-driven scripts."}),"\n",(0,a.jsx)(n.p,{children:"Example (minimal session flow):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from pioreactor.calibrations.session_flow import SessionStep\nfrom pioreactor.calibrations.session_flow import StepRegistry\nfrom pioreactor.calibrations.session_flow import advance_session\nfrom pioreactor.calibrations.session_flow import get_session_step\nfrom pioreactor.calibrations.session_flow import run_session_in_cli\nfrom pioreactor.calibrations.session_flow import steps, fields\nfrom pioreactor.calibrations.structured_session import CalibrationSession\nfrom pioreactor.calibrations.structured_session import utc_iso_timestamp\nfrom pioreactor.utils.timing import current_utc_datetime\nfrom pioreactor import structs\n\nclass Intro(SessionStep):\n    step_id = "intro"\n\n    def render(self, ctx):\n        return steps.info("pH calibration", "Place probe in buffer.")\n\n    def advance(self, ctx):\n        return Measure()\n\nclass Measure(SessionStep):\n    step_id = "measure"\n\n    def render(self, ctx):\n        return steps.form(\n            "Measure buffer",\n            "Record voltage and pH.",\n            [fields.float("voltage", minimum=0), fields.float("ph", minimum=0, maximum=14)],\n        )\n\n    def advance(self, ctx):\n        voltage = ctx.inputs.float("voltage", minimum=0)\n        ph_value = ctx.inputs.float("ph", minimum=0, maximum=14)\n        calibration = structs.CalibrationBase(\n            calibration_name="ph-cal",\n            calibrated_on_pioreactor_unit="unit",\n            created_at=current_utc_datetime(),\n            curve_type="poly",\n            curve_data_=[1.0, 0.0],\n            x="voltage",\n            y="ph",\n            recorded_data={"x": [voltage], "y": [ph_value]},\n        )\n        link = ctx.store_calibration(calibration, "ph")\n        ctx.complete({"calibration": link})\n        return None\n\nPH_STEPS: StepRegistry = {\n    Intro.step_id: Intro,\n    Measure.step_id: Measure,\n}\n\ndef start_ph_session() -> CalibrationSession:\n    now = utc_iso_timestamp()\n    return CalibrationSession(\n        session_id="...",\n        protocol_name="ph_two_point",\n        target_device="ph",\n        status="in_progress",\n        step_id=Intro.step_id,\n        data={},\n        created_at=now,\n        updated_at=now,\n    )\n\ndef get_ph_step(session, executor=None):\n    return get_session_step(PH_STEPS, session, executor)\n\ndef advance_ph_session(session, inputs, executor=None):\n    return advance_session(PH_STEPS, session, inputs, executor)\n\ndef run_ph_calibration():\n    session = start_ph_session()\n    return run_session_in_cli(PH_STEPS, session)\n'})}),"\n",(0,a.jsx)(n.p,{children:"Example chart metadata (render side):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'chart = {\n    "title": "Calibration progress",\n    "x_label": "Voltage",\n    "y_label": "pH",\n    "series": [{"id": "ph", "label": "Measured", "points": [{"x": 2.1, "y": 7.0}]}],\n}\nstep = steps.form("Measure", "Record reading.", [...])\nstep.metadata = {"chart": chart}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"adding-it-to-the-plugins-folder",children:"Adding it to the plugins folder"}),"\n",(0,a.jsxs)(n.p,{children:["You can add your code to the ",(0,a.jsx)(n.code,{children:"~/.pioreactor/plugins"})," folder on the Pioreactor, it will auto-magically populate the CLI\nand UI. To complete our pH example, add the following to a new Python file in the ",(0,a.jsx)(n.code,{children:"~/.pioreactor/plugins"})," folder:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from __future__ import annotations\nfrom pioreactor.calibrations import CalibrationProtocol\nfrom pioreactor.structs import CalibrationBase\nfrom pioreactor.utils.timing import current_utc_datetime\nfrom pioreactor import whoami\nimport typing as t\nfrom pioreactor.calibrations.session_flow import SessionStep\nfrom pioreactor.calibrations.session_flow import StepRegistry\nfrom pioreactor.calibrations.session_flow import advance_session\nfrom pioreactor.calibrations.session_flow import get_session_step\nfrom pioreactor.calibrations.session_flow import run_session_in_cli\nfrom pioreactor.calibrations.session_flow import steps, fields\nfrom pioreactor.calibrations.structured_session import CalibrationSession\nfrom pioreactor.calibrations.structured_session import utc_iso_timestamp\n\nclass PHBufferCalibration(CalibrationBase, kw_only=True, tag="ph_buffer"):\n    x: str = "pH"       # required\n    y: str = "Voltage"  # required\n\n    buffer_solution: t.Literal["4.01", "7.00", "10.01"]\n    electrode_type: str\n\n    def voltage_to_ph(self, voltage: float):\n        return self.y_to_x(voltage)\n\n    def ph_to_voltage(self, ph: float):\n        return self.x_to_y(ph)\n\nclass BufferBasedPHProtocol(CalibrationProtocol):\n    target_device = "ph"\n    protocol_name = "buffer_based"\n    description = "Calibrate the pH sensor using buffer solutions"\n    step_registry = PH_STEPS\n\n    @classmethod\n    def start_session(cls, target_device: str) -> CalibrationSession:\n        return start_ph_buffer_session(target_device)\n    step_registry = PH_STEPS\n\n    @classmethod\n    def start_session(cls, target_device: str) -> CalibrationSession:\n        return start_ph_buffer_session(target_device)\n\n    def run(self, target_device: str):\n        return run_ph_buffer_calibration()\n\ndef run_ph_buffer_calibration():\n    # run the calibration to get data\n    ...\n\n    return PHBufferCalibration(\n        calibration_name="ph_calibration",\n        calibrated_on_pioreactor_unit=whoami.get_unit_name(),\n        created_at=current_utc_datetime(),\n        curve_data_=[2, 3, 5],\n        curve_type="poly",\n        x="Voltage",\n        y="pH",\n        recorded_data={"x": [0.1, 0.2, 0.3], "y": [1.0, 2.0, 3.0]},\n        buffer_solution="default",\n        electrode_type="glass"\n    )\n\n# Session steps (UI + CLI flow)\nclass Intro(SessionStep):\n    step_id = "intro"\n\n    def render(self, ctx):\n        return steps.info("pH calibration", "Place probe in buffer.")\n\n    def advance(self, ctx):\n        return Measure()\n\nclass Measure(SessionStep):\n    step_id = "measure"\n\n    def render(self, ctx):\n        return steps.form(\n            "Measure buffer",\n            "Record voltage and pH.",\n            [fields.float("voltage", minimum=0), fields.float("ph", minimum=0, maximum=14)],\n        )\n\n    def advance(self, ctx):\n        voltage = ctx.inputs.float("voltage", minimum=0)\n        ph_value = ctx.inputs.float("ph", minimum=0, maximum=14)\n        calibration = PHBufferCalibration(\n            calibration_name="ph_calibration",\n            calibrated_on_pioreactor_unit=whoami.get_unit_name(),\n            created_at=current_utc_datetime(),\n            curve_data_=[1.0, 0.0],\n            curve_type="poly",\n            x="Voltage",\n            y="pH",\n            recorded_data={"x": [voltage], "y": [ph_value]},\n            buffer_solution="default",\n            electrode_type="glass",\n        )\n        link = ctx.store_calibration(calibration, "ph")\n        ctx.complete({"calibration": link})\n        return None\n\nPH_STEPS: StepRegistry = {\n    Intro.step_id: Intro,\n    Measure.step_id: Measure,\n}\n\ndef start_ph_buffer_session(target_device: str) -> CalibrationSession:\n    now = utc_iso_timestamp()\n    return CalibrationSession(\n        session_id="...",\n        protocol_name="buffer_based",\n        target_device=target_device,\n        status="in_progress",\n        step_id=Intro.step_id,\n        data={},\n        created_at=now,\n        updated_at=now,\n    )\n\ndef get_ph_buffer_step(session, executor=None):\n    return get_session_step(PH_STEPS, session, executor)\n\ndef advance_ph_buffer_session(session, inputs, executor=None):\n    return advance_session(PH_STEPS, session, inputs, executor)\n\ndef run_ph_buffer_session_cli():\n    session = start_ph_buffer_session("ph")\n    return run_session_in_cli(PH_STEPS, session)\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"And run it with:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"pio calibrations run --device ph\n"})}),"\n",(0,a.jsx)(n.h2,{id:"tips",children:"Tips"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["use session-based ",(0,a.jsx)(n.code,{children:"SessionStep"})," flows to define CLI and UI behavior in one place."]}),"\n",(0,a.jsxs)(n.li,{children:["the pair ",(0,a.jsx)(n.code,{children:"(device, calibration_name)"})," must be unique. The final directory structure looks like ",(0,a.jsx)(n.code,{children:"~/.pioreactor/storage/calibrations/<device>/<calibration_name>.yaml"})]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"x"})," variable should be the independent variable - the variable that can (in theory) be set by you, and the measurement variable ",(0,a.jsx)(n.code,{children:"y"})," follows. For example, in the default OD calibration, the independent variable is the OD, and the dependent variable is the Pioreactor's sensor's voltage. This is because we can vary the OD as we wish (add more culture...), and the Pioreactor's sensor will detect different values."]}),"\n",(0,a.jsx)(n.li,{children:'Another way to look at this is: "where does error exist"? Typically, there will be error in the "measurement" variable (voltage for OD calibration, RPM measurement for stirring calibration, etc.). In practice, we only have the measurement variable, and wish to go "back" to the original variable.'}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453(e,n,t){t.d(n,{R:()=>o,x:()=>s});var i=t(96540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);